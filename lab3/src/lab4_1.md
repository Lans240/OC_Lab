Отличные вопросы! Это ключевые механизмы управления процессами и обработки сигналов в операционных системах (ОС) семейства Unix/Linux. Давайте разберем каждый из них подробно.

---

### 1. Функция `kill`

**Назначение:** Функция `kill` используется для отправки **сигнала** другому процессу. Важно отметить, что её название вводит в заблуждение — она отправляет не только сигнал завершения (`SIGKILL`), но и любой другой сигнал.

**Синтаксис (язык C):**
```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

**Параметры:**
*   `pid`: Идентификатор процесса (Process ID), которому отправляется сигнал.
    *   `pid > 0`: Сигнал отправляется процессу с этим PID.
    *   `pid == 0`: Сигнал отправляется всем процессам в **группе процессов** текущего процесса.
    *   `pid == -1`: Сигнал отправляется всем процессам, на которые у текущего процесса есть права для отправки сигналов (это не обязательно все процессы в системе).
    *   `pid < -1`: Сигнал отправляется всем процессам в группе с ID, равным `|pid|`.
*   `sig`: Номер или макрос сигнала, который нужно отправить (например, `SIGTERM`, `SIGKILL`, `SIGUSR1`).

**Возвращаемое значение:**
*   `0` в случае успеха.
*   `-1` в случае ошибки (и переменная `errno` устанавливается соответствующим образом).

**Примеры использования:**
*   `kill(1234, SIGTERM);` — Вежливо попросить процесс с PID 1234 завершиться (у него есть шанс выполнить "уборку").
*   `kill(1234, SIGKILL);` — Немедленно и безусловно "убить" процесс с PID 1234. Этот сигнал нельзя перехватить или проигнорировать.
*   `kill(getpid(), SIGSTOP);` — Процесс отправляет сам себе сигнал `SIGSTOP`, чтобы приостановить своё выполнение.

**Важно в контексте ОС:** `kill` — это системный вызов, который является одним из основных механизмов **межпроцессного взаимодействия (Inter-Process Communication, IPC)**. ОС гарантирует доставку сигнала целевому процессу, если у отправителя есть на это права.

---

### 2. Неблокирующий `wait` с `WNOHANG`

**Назначение:** Функции `wait()` и `waitpid()` используются процессом-родителем для ожидания изменения состояния своего дочернего процесса (например, его завершения). Обычный `wait()` **блокирует** выполнение родителя до тех пор, пока один из дочерних процессов не завершится. Флаг `WNOHANG` делает этот вызов **неблокирующим**.

**Синтаксис (с `WNOHANG`):**
```c
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
// Чаще всего используется с WNOHANG
```

**Параметры (для `waitpid`):**
*   `pid`: Указывает, кого ждать (например, `-1` — любого дочернего процесса).
*   `status`: Указатель на целое число, куда будет записана информация о статусе завершения дочернего процесса (можно анализировать с помощью макросов, например, `WIFEXITED`).
*   `options`: Флаги. Флаг `WNOHANG` заставляет функцию немедленно вернуть управление, если ни один из дочерних процессов ещё не завершился.

**Возвращаемое значение (с `WNOHANG`):**
*   `> 0`: PID завершившегося дочернего процесса.
*   `0`: Ни один из дочерних процессов ещё не сменил состояние (то есть, все ещё работают). Родитель не блокируется и может продолжать свою работу.
*   `-1`: Ошибка (например, больше нет дочерних процессов).

**Пример использования (цикл опроса):**
```c
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Код потомка: делает какую-то работу
        sleep(2);
        return 42;
    } else {
        // Код родителя
        int status;
        pid_t child_pid;

        while (1) {
            // Неблокирующий опрос: "Закончил ли ребёнок?"
            child_pid = waitpid(-1, &status, WNOHANG);

            if (child_pid == 0) {
                printf("Дочерний процесс ещё работает...\n");
                sleep(1); // Родитель может делать свою работу здесь
            } else if (child_pid > 0) {
                printf("Дочерний процесс %d завершился с кодом %d.\n", child_pid, WEXITSTATUS(status));
                break;
            } else {
                perror("waitpid failed");
                break;
            }
        }
    }
    return 0;
}
```

**Важно в контексте ОС:** Этот механизм позволяет реализовать **асинхронное ожидание**. Родительский процесс не переводится ОС в состояние блокировки, а продолжает выполняться, периодически опрашивая состояние потомков. Это фундаментальный паттерн для написания эффективных серверов, которые должны одновременно обслуживать запросы и следить за своими "рабочими" процессами.

---

### 3. Функция `alarm`, сигнал `SIGALRM`, функция `signal`

#### `alarm`

**Назначение:** Устанавливает "будильник" для текущего процесса. По истечении указанного времени ядро ОС отправит процессу сигнал `SIGALRM`.

**Синтаксис:**
```c
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
```
*   `seconds`: Через сколько секунд отправить сигнал `SIGALRM`. Если передать `0`, предыдущий будильник (если был) будет отменен.
*   **Возвращаемое значение:** Количество секунд, оставшихся до срабатывания предыдущего будильника, или `0`, если будильник ранее не был установлен.

#### `SIGALRM`

**Назначение:** Это стандартный сигнал, посылаемый процессу по истечении времени, установленного вызовом `alarm()`. **Действие по умолчанию** — завершение процесса.

#### `signal`

**Назначение:** Устанавливает **обработчик сигнала** — функцию, которая будет вызвана, когда процесс получит конкретный сигнал. Это позволяет переопределить поведение процесса по умолчанию.

**Синтаксис:**
```c
#include <signal.h>

void (*signal(int sig, void (*func)(int)))(int);
```
Более читаемый вариант — использование `typedef`:
```c
typedef void (*sighandler_t)(int);
sighandler_t signal(int sig, sighandler_t handler);
```
*   `sig`: Номер сигнала, для которого устанавливается обработчик (например, `SIGALRM`).
*   `handler`: Указатель на функцию-обработчик. Может быть:
    *   Адрес пользовательской функции.
    *   `SIG_IGN`: Игнорировать сигнал (для `SIGALRM` это бессмысленно, так как таймер сработает впустую).
    *   `SIG_DFL`: Восстановить поведение по умолчанию.

**Пример совместного использования:**

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

// Пользовательский обработчик для SIGALRM
void alarm_handler(int signum) {
    printf ("Будильник сработал! Получен сигнал %d.\n", signum);
    // Здесь можно выполнить какие-то действия по таймауту
    exit(0); // Завершаем работу
}

int main() {
    // Устанавливаем наш обработчик для SIGALRM
    if (signal(SIGALRM, alarm_handler) == SIG_ERR) {
        perror("Невозможно установить обработчик сигнала");
        return 1;
    }

    printf("Устанавливаем будильник на 5 секунд.\n");
    alarm(5); // Заводим будильник

    // Бесконечный цикл, который прервет сигнал
    while(1) {
        printf("Ожидание... (PID: %d)\n", getpid());
        sleep(1); // Имитация работы
    }

    return 0;
}
```

**Что произойдет:**
1.  Процесс устанавливает функцию `alarm_handler` как обработчик для `SIGALRM`.
2.  Вызов `alarm(5)` говорит ядру ОС: "Отправь мне сигнал `SIGALRM` через 5 секунд".
3.  Процесс уходит в цикл.
4.  Через 5 секунд **ядро ОС** приостанавливает выполнение основного кода процесса и передает управление в функцию `alarm_handler`.
5.  Обработчик печатает сообщение и завершает программу.

**Важно в контексте ОС:** Это пример **асинхронного обработчика события (asynchronous event handling)**. ОС использует механизм сигналов для уведомления процессов о различных событиях (истечение времени, завершение дочернего процесса, попытка недопустимой операции и т.д.). Функция `signal` — это старый, но наглядный способ подписаться на эти события. В современном коде рекомендуется использовать более надежный и гибкий системный вызов `sigaction`.