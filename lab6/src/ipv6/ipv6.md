## Общая архитектура системы

Система состоит из трех основных компонентов:
1. **Библиотека умножения** (`multmodulo.c`) - математические операции
2. **Сервер** (`serveripv6.c`) - вычисляет части факториала
3. **Клиент** (`clientipv6.c`) - распределяет задачи между серверами

---

## 1. Библиотека умножения (`multmodulo.c`)

### Назначение
Безопасное умножение больших чисел по модулю без переполнения.

### Алгоритм
```c
uint64_t MultModulo(uint64_t a, uint64_t b, uint64_t mod) {
  uint64_t result = 0;
  a = a % mod;  // Нормализуем a
  while (b > 0) {
    if (b % 2 == 1)        // Если b нечетное
      result = (result + a) % mod;  // Добавляем a к результату
    a = (a * 2) % mod;     // Удваиваем a
    b /= 2;                // Делим b пополам
  }
  return result % mod;
}
```

**Как это работает:**
- Использует алгоритм "русского крестьянского умножения"
- Преобразует умножение в серию сложений и сдвигов
- На каждой итерации:
  - Если младший бит `b` равен 1, добавляем `a` к результату
  - Удваиваем `a` и делим `b` на 2
- Все операции выполняются по модулю для избежания переполнения

---

## 2. Сервер (`serveripv6.c`)

### Назначение
Принимает диапазоны чисел от клиента, вычисляет произведение чисел в этом диапазоне по модулю.

### Ключевые структуры данных

```c
struct FactorialArgs {
  uint64_t begin;    // Начало диапазона
  uint64_t end;      // Конец диапазона  
  uint64_t mod;      // Модуль для вычислений
};
```

### Основные функции

#### Функция вычисления факториала диапазона
```c
uint64_t Factorial(const struct FactorialArgs *args) {
  uint64_t ans = 1;
  for (uint64_t i = args->begin; i <= args->end; i++) {
    ans = MultModulo(ans, i, args->mod);
  }
  return ans;
}
```

#### Потоковая функция
```c
void *ThreadFactorial(void *args) {
  struct FactorialArgs *fargs = (struct FactorialArgs *)args;
  uint64_t *result = malloc(sizeof(uint64_t));
  *result = Factorial(fargs);
  return (void *)result;
}
```

### Работа сервера

1. **Инициализация:**
   - Парсинг аргументов командной строки (`--port`, `--tnum`)
   - Создание IPv6 сокета
   - Привязка к порту и начало прослушивания

2. **Обработка подключений:**
   - Принимает входящие соединения
   - Читает данные от клиента: 3 числа uint64_t (begin, end, mod)

3. **Распределение работы по потокам:**
   - Делит полученный диапазон на равные части по количеству потоков
   - Создает потоки для параллельного вычисления
   - Пример для диапазона 1-100 и 4 потоков:
     - Поток 1: 1-25
     - Поток 2: 26-50  
     - Поток 3: 51-75
     - Поток 4: 76-100

4. **Сбор результатов:**
   - Ожидает завершения всех потоков
   - Перемножает результаты потоков используя `MultModulo`
   - Отправляет итоговый результат клиенту

---

## 3. Клиент (`clientipv6.c`)

### Назначение
Распределяет вычисление факториала между несколькими серверами.

### Ключевые структуры данных

```c
struct Server {
  char ip[255];    // IP-адрес сервера
  int port;        // Порт сервера
};

struct ThreadData {
  struct Server server;  // Информация о сервере
  uint64_t begin;        // Начало диапазона для сервера
  uint64_t end;          // Конец диапазона для сервера
  uint64_t mod;          // Модуль
  uint64_t result;       // Результат от сервера
  int success;           // Флаг успешности выполнения
};
```

### Основные функции

#### Обработка одного сервера
```c
void* ProcessServer(void* arg) {
  struct ThreadData* data = (struct ThreadData*)arg;
  
  // Создание сокета и подключение
  int sck = socket(AF_INET6, SOCK_STREAM, 0);
  
  // Настройка структуры адреса сервера
  struct sockaddr_in6 server;
  // ...
  
  // Подключение с таймаутом 5 секунд
  struct timeval timeout = {5, 0};
  setsockopt(sck, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
  setsockopt(sck, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
  
  // Отправка задачи серверу
  char task[sizeof(uint64_t) * 3];
  memcpy(task, &data->begin, sizeof(uint64_t));
  // ...
  
  // Получение результата
  char response[sizeof(uint64_t)];
  recv(sck, response, sizeof(response), 0);
  
  return NULL;
}
```

### Работа клиента

1. **Инициализация:**
   - Парсинг аргументов (`--k`, `--mod`, `--servers`)
   - Чтение файла с серверами

2. **Парсинг файла серверов:**
   - Поддерживает несколько форматов:
     - `[IPv6]:port` (с квадратными скобками)
     - `IPv4:port` или `IPv6:port` (без скобок)
   - Пример содержимого файла:
     ```
     [::1]:20001
     [::1]:20002
     [::1]:20003
     ```

3. **Распределение работы:**
   - Делит диапазон 1..k между серверами
   - Пример для k=20 и 3 серверов:
     - Сервер 1: 1-6
     - Сервер 2: 7-12  
     - Сервер 3: 13-20

4. **Параллельное выполнение:**
   - Создает по потоку для каждого сервера
   - Каждый поток подключается к своему серверу и отправляет задачу
   - Устанавливает таймауты на операции

5. **Сбор результатов:**
   - Ожидает завершения всех потоков
   - Перемножает результаты от всех серверов
   - Выводит итоговый результат: k! mod mod

---

## Протокол взаимодействия

### Формат данных
- Все числа передаются как uint64_t в бинарном формате
- Порядок байтов - сетевой (big-endian)

### Сообщение от клиента к серверу:
```
[8 байт: begin][8 байт: end][8 байт: mod]
```

### Ответ от сервера клиенту:
```
[8 байт: результат]
```

---

## Пример работы

1. **Запуск серверов:**
```bash
./server --port 20001 --tnum 2
./server --port 20002 --tnum 2  
./server --port 20003 --tnum 2
```

2. **Запуск клиента:**
```bash
./client --k 20 --mod 100000 --servers servers.txt
```

3. **Что происходит:**
   - Клиент делит вычисление 20! на 3 части
   - Каждый сервер получает свой диапазон и вычисляет произведение
   - Серверы внутри себя делят работу на 2 потока
   - Клиент собирает результаты и вычисляет итог

---

## Особенности реализации

### Безопасность вычислений
- Используется модульная арифметика для избежания переполнения
- Все промежуточные результаты берутся по модулю

### Обработка ошибок
- Таймауты на подключение и операции
- Проверка корректности полученных данных
- Флаги успешности выполнения для каждого сервера

### Производительность
- Параллелизм на уровне серверов (клиент)
- Параллелизм на уровне потоков (сервер)
- Эффективный алгоритм умножения

### Поддержка IPv6
- Использование `AF_INET6`
- Поддержка IPv6 адресов в различных форматах
- Универсальная обработка адресов

Эта система демонстрирует классический подход к распределенным вычислениям с балансировкой нагрузки и параллельной обработкой данных.