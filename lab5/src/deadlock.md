1. **Сборка программы**:
   ```bash
   gcc -o deadlock_program deadlock.c -lpthread
   ```

2. **Запуск программы**:
   ```bash
   ./deadlock_program
   ```

3. **Что произойдет**:
   - Программа выведет сообщения о захвате мьютексов и зависнет.
   - Вывод будет выглядеть примерно так:
     ```
     Поток 1: захватил мьютекс 1
     Поток 2: захватил мьютекс 2
     Поток 1: пытается захватить мьютекс 2
     Поток 2: пытается захватить мьютекс 1
     ```
   - После этого программа не завершится, так как потоки заблокируют друг друга.

4. **Как завершить программу**:
   - Нажмите `Ctrl + C` в терминале, чтобы принудительно остановить программу.

---

### Объяснение deadlock:
1. Поток 1 захватывает `mutex1`, а поток 2 — `mutex2`.
2. Оба потока ждут 1 секунду (имитация работы).
3. Поток 1 пытается захватить `mutex2`, но он уже занят потоком 2.
4. Поток 2 пытается захватить `mutex1`, но он уже занят потоком 1.
5. Оба потока бесконечно ждут друг друга — это и есть **deadlock**.

---

### Дополнительный совет:
Если хотите быть уверенным в deadlock, можно добавить вывод перед каждым `pthread_mutex_lock` и использовать `fflush(stdout)`:
```c
printf("Поток 1: пытается захватить мьютекс 2\n");
fflush(stdout);
pthread_mutex_lock(&mutex2);
```


### Что такое Deadlock?

**Deadlock** (взаимная блокировка) — это ситуация в многопоточном или многопроцессном программировании, когда два или более потока/процесса бесконечно ожидают друг друга, не имея возможности продолжить выполнение.

### Четыре необходимых условия для возникновения Deadlock

Для возникновения взаимной блокировки должны одновременно выполняться **все четыре** условия:

#### 1. **Взаимное исключение (Mutual Exclusion)**
- Ресурсы не могут использоваться совместно
- Только один поток может использовать ресурс в данный момент времени
- **Пример**: Мьютексы, семафоры, критические секции

#### 2. **Удержание и ожидание (Hold and Wait)**
- Поток удерживает как минимум один ресурс и ожидает получения дополнительных ресурсов, которые в данный момент удерживаются другими потоками

#### 3. **Отсутствие вытеснения (No Preemption)**
- Ресурсы не могут быть принудительно отобраны у потоков
- Ресурс освобождается только тогда, когда поток добровольно его отпускает

#### 4. **Циклическое ожидание (Circular Wait)**
- Существует циклическая цепочка потоков, где каждый поток ждет ресурс, удерживаемый следующим потоком в цепочке

### Классический пример: "Проблема обедающих философов"

Пять философов сидят за круглым столом, между ними лежат пять вилок. Чтобы поесть, философу нужны две вилки. Если все философы возьмут по одной вилке, они будут вечно ждать вторую — это deadlock.

### Как происходит Deadlock в программировании

```c
// Упрощенная схема deadlock
Поток 1:               Поток 2:
lock(mutex1);          lock(mutex2);
// Работает...         // Работает...
lock(mutex2);          lock(mutex1);  // DEADLOCK!
```

### Типичные сценарии возникновения

#### 1. **Неправильный порядок блокировок**
```c
// Поток 1: mutex1 -> mutex2
// Поток 2: mutex2 -> mutex1  // DEADLOCK!
```

#### 2. **Исключения в критических секциях**
```c
pthread_mutex_lock(&mutex1);
// Если здесь произойдет исключение...
pthread_mutex_lock(&mutex2);  // ...эта строка не выполнится
pthread_mutex_unlock(&mutex1); // и мьютекс не освободится
```

#### 3. **Рекурсивные вызовы**
```c
void functionA() {
    lock(mutex1);
    functionB();  // Требует mutex2
    unlock(mutex1);
}

void functionB() {
    lock(mutex2);
    functionA();  // Требует mutex1 - возможен deadlock
    unlock(mutex2);
}
```

### Методы предотвращения Deadlock

#### 1. **Упорядочивание блокировок**
```c
// Всегда захватывать мьютексы в одинаковом порядке
void thread1() {
    pthread_mutex_lock(&mutex1);  // Сначала mutex1
    pthread_mutex_lock(&mutex2);  // Потом mutex2
    // работа...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
}

void thread2() {
    pthread_mutex_lock(&mutex1);  // Тоже сначала mutex1
    pthread_mutex_lock(&mutex2);  // Потом mutex2
    // работа...
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
}
```

#### 2. **Использование trylock с таймаутами**
```c
if (pthread_mutex_trylock(&mutex2) != 0) {
    // Не удалось захватить - освобождаем первый мьютекс
    pthread_mutex_unlock(&mutex1);
    // Пробуем снова или ждем
}
```

#### 3. **Иерархия ресурсов**
- Присвоить ресурсам номера (уровни)
- Всегда захватывать ресурсы в порядке возрастания номеров

#### 4. **Использование мониторов или высокоуровневых конструкций**
```c
// Использование std::lock в C++ (захватывает несколько мьютексов атомарно)
std::lock(mutex1, mutex2);
```

### Обнаружение Deadlock

#### 1. **Граф ожидания ресурсов**
- Узлы: потоки и ресурсы
- Ребро T→R: поток T ожидает ресурс R
- Ребро R→T: ресурс R удерживается потоком T
- **Цикл в графе = deadlock**

#### 2. **Инструменты для обнаружения**
- **Valgrind (Helgrind, DRD)**
- **Clang ThreadSanitizer**
- **GDB** с анализом стека вызовов

### Практический пример обнаружения

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1(void* arg) {
    printf("Поток 1: пытается захватить mutex1\n");
    pthread_mutex_lock(&mutex1);
    printf("Поток 1: захватил mutex1\n");
    
    sleep(1);  // Даем время потоку 2 захватить mutex2
    
    printf("Поток 1: пытается захватить mutex2\n");
    pthread_mutex_lock(&mutex2);  // DEADLOCK!
    printf("Поток 1: захватил mutex2\n");
    
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2(void* arg) {
    printf("Поток 2: пытается захватить mutex2\n");
    pthread_mutex_lock(&mutex2);
    printf("Поток 2: захватил mutex2\n");
    
    sleep(1);  // Даем время потоку 1 захватить mutex1
    
    printf("Поток 2: пытается захватить mutex1\n");
    pthread_mutex_lock(&mutex1);  // DEADLOCK!
    printf("Поток 2: захватил mutex1\n");
    
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    pthread_create(&t1, NULL, thread1, NULL);
    pthread_create(&t2, NULL, thread2, NULL);
    
    // Ждем немного - программа зависнет в deadlock
    sleep(3);
    
    printf("Программа не завершится нормально - deadlock!\n");
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    return 0;
}
```

### Практические рекомендации

1. **Проектируйте код так, чтобы минимизировать необходимость в нескольких блокировках**

2. **Всегда освобождайте ресурсы в порядке, обратном их захвату**

3. **Используйте таймауты для операций блокировки**

4. **Избегайте вызовов внешнего кода из критических секций**

5. **Используйте инструменты статического анализа для выявления потенциальных deadlock'ов**

Deadlock — одна из самых коварных проблем в параллельном программировании, потому что она может не проявляться при каждом запуске программы, а только при определенных условиях времени выполнения.