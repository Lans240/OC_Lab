# Детальный разбор лабораторной работы: TCP и UDP клиент-серверные приложения

## 1. Компиляция программ на языке C

### Процесс компиляции
```bash
gcc -Wall -std=c99 -o программа исходник.c
```
- **gcc** - компилятор GNU C
- **-Wall** - включение всех предупреждений (помогает найти потенциальные ошибки)
- **-std=c99** - использование стандарта C99
- **-o программа** - указание имени выходного файла

### Makefile - система сборки
```makefile
CC = gcc                    # Определение компилятора
CFLAGS = -Wall -std=c99     # Флаги компиляции

all: tcpclient tcpserver udpclient udpserver  # Цель по умолчанию

tcpclient: tcpclient.c      # Правило для сборки tcpclient
    $(CC) $(CFLAGS) -o tcpclient tcpclient.c
```
Makefile автоматизирует процесс компиляции, позволяя одной командой `make` собрать все программы.

## 2. Аргументы командной строки

### Обработка аргументов в программах
```c
if (argc < 4) {
    printf("Usage: %s <IP> <PORT> <BUFSIZE>\n", argv[0]);
    exit(1);
}
```
- **argc** - количество аргументов
- **argv[]** - массив строк-аргументов
- **argv[0]** - имя программы
- **argv[1], argv[2], ...** - пользовательские аргументы

### Преобразование типов
```c
int bufsize = atoi(argv[3]);        // строка -> число
servaddr.sin_port = htons(atoi(argv[2]));  // преобразование порта в сетевой порядок
```

## 3. Детальный разбор TCP приложений

### TCP Клиент (tcpclient.c)

#### Создание сокета
```c
fd = socket(AF_INET, SOCK_STREAM, 0)
```
- **AF_INET** - IPv4 адресация
- **SOCK_STREAM** - потоковый сокет (TCP)
- **0** - протокол по умолчанию

#### Настройка адреса сервера
```c
memset(&servaddr, 0, SIZE);         // обнуление структуры
servaddr.sin_family = AF_INET;      // IPv4
servaddr.sin_port = htons(atoi(argv[2]));  // порт
inet_pton(AF_INET, argv[1], &servaddr.sin_addr);  // IP-адрес
```

#### Установка соединения
```c
connect(fd, (SADDR *)&servaddr, SIZE)
```
Блокирующий вызов, который:
1. Отправляет SYN пакет серверу
2. Ждет SYN-ACK ответ
3. Отправляет ACK (трехстороннее рукопожатие)

#### Передача данных
```c
while ((nread = read(0, buf, bufsize)) > 0) {
    write(fd, buf, nread);
}
```
- **read(0, ...)** - чтение из stdin (клавиатура)
- **write(fd, ...)** - запись в сокет

### TCP Сервер (tcpserver.c)

#### Создание и привязка сокета
```c
lfd = socket(AF_INET, SOCK_STREAM, 0);  // слушающий сокет
bind(lfd, (SADDR *)&servaddr, kSize);   // привязка к порту
listen(lfd, 5);                         // начало прослушивания
```

#### Цикл принятия соединений
```c
while (1) {
    cfd = accept(lfd, (SADDR *)&cliaddr, &clilen);  // принятие соединения
    // обработка данных...
}
```

#### Обработка данных от клиента
```c
while ((nread = read(cfd, buf, bufsize)) > 0) {
    write(1, &buf, nread);  // вывод на stdout
}
```

## 4. Детальный разбор UDP приложений

### UDP Клиент (udpclient.c)

#### Создание сокета
```c
sockfd = socket(AF_INET, SOCK_DGRAM, 0)
```
- **SOCK_DGRAM** - датаграммный сокет (UDP)

#### Отправка и прием данных
```c
sendto(sockfd, sendline, n, 0, (SADDR *)&servaddr, SLEN);
recvfrom(sockfd, recvline, bufsize, 0, NULL, NULL);
```
Каждый вызов `sendto`/`recvfrom` - независимая операция.

### UDP Сервер (udpserver.c)

#### Основной цикл обработки
```c
while (1) {
    n = recvfrom(sockfd, mesg, bufsize, 0, (SADDR *)&cliaddr, &len);
    // обработка полученных данных
    sendto(sockfd, mesg, n, 0, (SADDR *)&cliaddr, len);
}
```
Сервер получает датаграмму и сразу отправляет ответ тому же адресу.

## 5. Ответы на вопросы

### Что делают оба приложения?

**TCP приложения:**
- Клиент устанавливает постоянное соединение с сервером
- Передает поток данных от пользователя к серверу
- Сервер принимает соединение и выводит полученные данные

**UDP приложения:**
- Клиент отправляет отдельные датаграммы серверу
- Сервер возвращает эхо-ответ на каждую датаграмму
- Каждая операция независима

### Что произойдет, если tcpclient отправит сообщение незапущенному серверу?

**Вызов `connect()` завершится с ошибкой:**
- `connect: Connection refused`
- Программа завершится с кодом ошибки
- **Причина:** Не найден слушающий процесс на указанном порту

### Что произойдет, если udpclient отправит сообщение незапущенному серверу?

**Клиент зависнет в `recvfrom()`:**
- `sendto()` успешно отправит данные в сеть
- `recvfrom()` будет бесконечно ждать ответа
- **Причина:** UDP не устанавливает соединение, отправка всегда "успешна"

### Что произойдет, если tcpclient отвалится во время работы с сервером?

**На сервере:**
- `read()` вернет 0 (конец файла)
- Сервер закроет клиентский сокет (`close(cfd)`)
- Выведется сообщение "connection established" для нового клиента
- **Причина:** TCP обнаруживает разрыв соединения

### Что произойдет, если udpclient отвалится во время работы с сервером?

**Сервер продолжит работать нормально:**
- UDP не отслеживает состояние клиентов
- Сервер будет ждать следующие датаграммы
- **Причина:** UDP не имеет состояния соединения

### Что произойдет, если udpclient отправит сообщение на несуществующий / выключенный сервер?

**Аналогично незапущенному серверу:**
- `sendto()` "успешно" отправит данные
- `recvfrom()` будет вечно ждать ответа
- Данные будут потеряны где-то в сети

### Что произойдет, если tcpclient отправит сообщение на несуществующий / выключенный сервер?

**Зависит от ситуации:**
- **Несуществующий IP:** `connect: Network is unreachable`
- **Выключенный сервер:** `connect: Connection timed out`
- **Заблокированный порт:** `connect: Connection refused`

## 6. Ключевые отличия UDP и TCP протоколов

### TCP (Transmission Control Protocol)
- **С установлением соединения** - трехстороннее рукопожатие
- **Надежная доставка** - подтверждения, повторные передачи
- **Упорядоченность данных** - порядковые номера пакетов
- **Контроль перегрузки** - динамическое окно перегрузки
- **Потоковая передача** - данные как непрерывный поток
- **Примеры использования:** HTTP, FTP, SSH, email

### UDP (User Datagram Protocol)
- **Без установления соединения** - сразу отправка данных
- **Ненадежная доставка** - нет подтверждений
- **Неупорядоченность** - пакеты могут приходить в любом порядке
- **Отсутствие контроля перегрузки**
- **Датаграммная передача** - отдельные пакеты
- **Примеры использования:** DNS, VoIP, видеостриминг, игры

### Сравнительная таблица
| Характеристика | TCP | UDP |
|----------------|-----|-----|
| Соединение | Устанавливается | Нет соединения |
| Надежность | Гарантированная | Не гарантирована |
| Упорядоченность | Сохраняется | Не сохраняется |
| Скорость | Медленнее | Быстрее |
| Накладные расходы | Высокие | Низкие |
| Контроль перегрузки | Есть | Нет |

## 7. Практические последствия различий

### Когда использовать TCP:
- Передача файлов
- Веб-страницы
- Электронная почта
- Удаленное управление
- **Когда важна надежность**

### Когда использовать UDP:
- VoIP и видеоконференции
- Онлайн-игры
- DNS запросы
- Трансляция видео
- **Когда важна скорость и малая задержка**

Эта лабораторная работа наглядно демонстрирует фундаментальные различия между двумя основными транспортными протоколами интернета.

# Углубленное понимание TCP и UDP: от теории к практике

## 1. Уровневая модель и место TCP/UDP в стеке протоколов

### Модель OSI vs TCP/IP
```
Прикладной уровень (HTTP, FTP, DNS)      <- Наши приложения работают здесь
Транспортный уровень (TCP, UDP)          <- TCP/UDP работают здесь
Сетевой уровень (IP, ICMP)               <- Маршрутизация пакетов
Канальный уровень (Ethernet, WiFi)       <- Передача между соседними узлами
Физический уровень                        <- Сигналы по проводам/воздуху
```

**Ключевой момент:** TCP и UDP - это транспортные протоколы, которые обеспечивают связь между приложениями на разных компьютерах.

## 2. Внутреннее устройство TCP

### Структура TCP-сегмента
```
| Source Port | Dest Port | Sequence Number | Ack Number | Flags | Window | Checksum | Urgent | Data |
```

**Sequence Number** - номер первого байта в сегменте
**Ack Number** - номер следующего ожидаемого байта
**Flags** - управляющие биты (SYN, ACK, FIN, RST)

### Механизм скользящего окна
```c
// Упрощенная концепция
#define WINDOW_SIZE 4096  // Размер окна в байтах

// Отправитель может отправлять данные без подтверждения
// пока не заполнит окно размером WINDOW_SIZE
```

**Как это работает:**
- Отправитель посылает данные в пределах окна
- Получатель подтверждает получение, сдвигая окно
- Если подтверждения не приходят - повторная передача

### Контроль перегрузки
TCP динамически регулирует скорость передачи на основе:
- **RTT (Round-Trip Time)** - время доставки пакета туда и обратно
- **Потери пакетов** - индикатор перегрузки сети
- **Размер окна** - увеличивается при успешной доставке, уменьшается при потерях

## 3. Внутреннее устройство UDP

### Структура UDP-датаграммы
```
| Source Port | Dest Port | Length | Checksum | Data |
```

**Простота** - всего 4 поля в заголовке
**Length** - общая длина датаграммы (заголовок + данные)

### Почему UDP быстрее?
```c
// TCP: множественные системные вызовы и проверки
connect() -> SYN, SYN-ACK, ACK         // 3 пакета
send() -> данные + ожидание ACK
close() -> FIN, ACK, FIN, ACK          // 4 пакета

// UDP: один вызов - одна датаграмма
sendto() -> данные ушли, забыли
```

## 4. Реальные сценарии использования

### Когда TCP обязательно нужен:
```c
// Банковские транзакции
transfer_money(account_from, account_to, amount);
// Потеря пакета = потеря денег!

// Загрузка файлов
download_file("important_document.pdf");
// Пропущенный пакет = corrupted file!
```

### Когда UDP предпочтительнее:
```c
// Видеозвонок
send_video_frame(frame_data);
// Лучше потерять кадр, чем ждать повторной передачи

// Онлайн-игра
send_player_position(x, y, z);
// Устаревшие данные бесполезны - лучше свежие
```

## 5. Проблемы и решения в реальных приложениях

### Проблемы TCP:
```c
// "Head-of-line blocking"
// Если пакет #3 потерялся, пакеты #4, #5, #6 ждут его
[1][2][X][4][5][6] -> [1][2][3_retry][4][5][6]
```

### Проблемы UDP:
```c
// Нужно реализовывать свою надежность
typedef struct {
    uint32_t sequence_number;
    uint32_t timestamp;
    uint16_t checksum;
    char data[1024];
} reliable_udp_packet_t;
```

## 6. Системные ограничения и настройки

### Лимиты операционной системы
```c
// Максимальное количество одновременных TCP-соединений
cat /proc/sys/net/ipv4/tcp_max_syn_backlog

// Размер буферов сокетов
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));
```

### Типичные значения:
- **TCP backlog**: 128-1024 соединений в очереди
- **Buffer sizes**: 8KB-2MB на сокет
- **Ephemeral ports**: 32768-60999 для клиентов

## 7. Отладка и мониторинг

### Полезные команды Linux:
```bash
# Просмотр установленных соединений
netstat -tunap

# Статистика по протоколам
netstat -s

# Мониторинг трафика в реальном времени
tcpdump -i any port 8080

# Информация о конкретном соединении
ss -t -i sport = 8080
```

### Коды ошибок и их значение:
```c
// Common errno values in network programming:
ECONNREFUSED  // Сервер отверг соединение
ETIMEDOUT     // Таймаут соединения
ECONNRESET    // Соединение сброшено удаленной стороной
EAGAIN        // Ресурс временно недоступен (non-blocking)
```

## 8. Производительность и оптимизация

### TCP оптимизации:
```c
// Nagle's algorithm - собирает мелкие пакеты
int flag = 1;
setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));

// Keepalive - проверяет живость соединения
int keepalive = 1;
setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &keepalive, sizeof(keepalive));
```

### UDP оптимизации:
```c
// Увеличиваем размер буфера для высокоскоростных приложений
int rcvbuf = 1024 * 1024;  // 1MB
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));
```

## 9. Безопасность considerations

### TCP уязвимости:
- **SYN flood** - атака переполнения очереди соединений
- **Session hijacking** - перехват установленного соединения

### UDP уязвимости:
- **Amplification attacks** - использование сервера для DDoS
- **Spoofing** - подделка исходного адреса

## 10. Практические примеры из реального мира

### Веб-сервер (TCP):
```c
// Apache/Nginx используют TCP потому что:
// - Надежная доставка HTML/CSS/JS критична
// - Большие файлы требуют контроля потока
// - HTTPS работает поверх TCP
```

### DNS сервер (UDP):
```c
// DNS использует UDP потому что:
// - Запросы-ответы маленькие и независимые
// - Низкая задержка важнее надежности
// - Повторный запрос дешевле реализации надежности
```

### Голосовой чат (UDP):
```c
// VoIP использует UDP потому что:
// - 100ms задержка заметна пользователю
// - Потеря 5% пакетов почти незаметна
// - Повторная передача голосовых данных бессмысленна
```

## 11. Эволюция протоколов

### Новые транспортные протоколы:
- **QUIC** - UDP-based, быстрее TCP с встроенной безопасностью
- **SCTP** - сочетает преимущества TCP и UDP
- **WebRTC** - P2P коммуникации поверх UDP

## Ключевые выводы для понимания:

1. **TCP** - это "надежный курьер" - гарантирует доставку, но может быть медленным
2. **UDP** - это "почтовая открытка" - быстрая, но без гарантий
3. **Выбор протокола** зависит от требований приложения к надежности vs задержке
4. **Современные приложения** часто используют оба протокола для разных задач

Эта информация должна дать вам глубокое понимание того, как работают сетевые приложения на практике и почему разработчики выбирают те или иные протоколы для конкретных задач.