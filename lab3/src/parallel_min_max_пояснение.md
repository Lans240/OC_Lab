# Пояснение работы `parallel_min_max`

---

## Краткий обзор

Программа параллельно ищет минимум и максимум в массиве целых чисел.  
Она делит массив на `pnum` частей, создаёт `pnum` дочерних процессов через `fork()`. Каждый ребёнок вычисляет min/max для своей части и передаёт результат родителю — либо через отдельный файл (`--by_files`), либо через отдельный `pipe` для каждого ребёнка. Родитель ждёт завершения детей, собирает частичные результаты и вычисляет общий минимум и максимум. Программа также выводит время выполнения в миллисекундах.

---

## Входные параметры (CLI)

- `--seed N` — seed для `srand()` (воспроизводимость).
- `--array_size N` — размер массива (количество элементов).
- `--pnum N` — количество дочерних процессов.
- `--by_files` или `-f` — использовать файлы для передачи результатов (если не указан — использовать pipe).

---

## Основные блоки программы

### Парсинг аргументов

- Используется `getopt_long`.
- Проверяем, что `seed`, `array_size` и `pnum` заданы и положительны.
- Если `pnum > array_size`, логично уменьшить `pnum = array_size`, чтобы не создавать пустых процессов.


### Генерация массива

- `malloc(sizeof(int) * array_size)` — выделение памяти.
- `GenerateArray(array, array_size, seed)` — заполняет `array` вызовами `rand()`.
  - Важно: цикл в `GenerateArray` должен использовать `unsigned int i`, чтобы не было предупреждения signed/unsigned.


### Подготовка IPC

- **Режим файлов (`--by_files`)**: дочерний процесс создаёт файл `minmax_i.txt` и пишет туда два числа `min max`.
- **Режим pipe (по умолчанию)**: для каждого ребёнка создаётся `pipe(pipes[i])`. Дочерний пишет два `int` в write-end своего pipe; родитель читает из соответствующего read-end.


### Разбиение массива (логика `begin/end`)

Для `i`-го процесса:

```
chunk_size = array_size / pnum;
remainder = array_size % pnum;
begin = i * chunk_size + (i < remainder ? i : remainder);
end = begin + chunk_size + (i < remainder ? 1 : 0);
```

- Результат — полуинтервал `[begin, end)` (end не включается).
- Остаток (`remainder`) распределяется по одному элементу на первые `remainder` частей.


---

## Что делает дочерний процесс (детально)

1. Вычисляет `begin` и `end` для своего индекса `i`.
2. Вызывает `GetMinMax(array, begin, end)`, где:
   - `min` инициализируется `INT_MAX`,
   - `max` инициализируется `INT_MIN`,
   - затем цикл `for (unsigned int k = begin; k < end; ++k)` обновляет min/max.
3. Передаёт результат:
   - если `with_files`: открывает `minmax_i.txt`, пишет `"%d %d\n"` и закрывает файл;
   - иначе: закрывает `pipes[i][0]`, делает `write(pipes[i][1], buf, sizeof(buf))`, где `buf[0]=min, buf[1]=max`, потом закрывает `pipes[i][1]`.
4. Освобождает ресурсы (`free(array)` и т. п.) и вызывает `_exit(0)`:
   - **важно**: использовать `_exit`, а не `exit`, чтобы не испортить буферы stdio в родительском процессе.


---

## Что делает родитель (детально)

1. Если используются pipe: после создания всех детей родитель закрывает все write-ends (`pipes[i][1]`) — он только читатель.
2. Ожидает завершения всех детей (`wait(NULL)` в цикле).
3. Считывает частичные результаты:
   - если файлы: открывает `minmax_i.txt`, `fscanf("%d %d", &min, &max)` и закрывает;
   - если pipe: `read(pipes[i][0], buf, sizeof(buf))`, затем `close(pipes[i][0])`.
4. Агрегирует результаты:
   ```
   global_min = min(global_min, min);
   global_max = max(global_max, max);
   ```
5. Выводит `Минимум`, `Максимум` и `Время выполнения` (ms). Освобождает память, удаляет или оставляет временные файлы по желанию.

---

## Измерение времени

- Используется `gettimeofday` до и после выполнения рабочих частей.
- Время вычисляется как:
  ```
  elapsed_ms = (finish.tv_sec - start.tv_sec) * 1000.0
             + (finish.tv_usec - start.tv_usec) / 1000.0;
  ```
- Это даёт грубую оценку общего времени (создание процессов, вычисления, IPC и т.д.).

---

## Важные технические детали и подводные камни

- **Закрывать неиспользуемые концы pipe**:
  - ребёнок закрывает `pipes[i][0]` (read-end);
  - родитель закрывает `pipes[i][1]` (write-end).
  Иначе `read` может не получить EOF и заблокироваться.
- **Используйте `_exit` в дочернем процессе**, чтобы не вызвать повторную очистку/флешинг буферов stdio.
- **Запись/чтение бинарных `int` в pipe** корректна при запуске на одной машине и одинаковой архитектуре; при переносе между машинами лучше сериализовать текстом или использовать фиксированные типы (`int32_t`) и порядок байт.
- **Если `begin >= end`** (пустой диапазон), `GetMinMax` возвращает `min=INT_MAX` и `max=INT_MIN` — такие значения не повлияют на итог агрегирования.
- **Права записи**: в режиме `--by_files` убедитесь, что программа может создавать файлы в текущей директории.
- **Если `pnum > array_size`**: код уменьшает `pnum` до `array_size`, чтобы не создавать пустые процессы.

---

## Частые вопросы (FAQ) — короткие ответы
- **Почему отдельный pipe на каждый ребёнок?**  
  Проще связать конкретный результат с конкретным ребёнком и избежать перемешивания сообщений.
- **Почему не использовать один общий pipe?**  
  Можно, но придётся вводить протокол маркировки сообщений и синхронизацию чтения; проще — отдельный pipe.
- **Почему не `exit()` в ребёнке?**  
  `exit()` выполнит обработчики `atexit` и может продублировать буферы stdio; `_exit` безопаснее.
- **Как сделать быстрее?**  
  Использовать `mmap`/shared memory или многопоточность (pthreads), чтобы избежать накладных расходов на fork и IPC.

---

## Как рассказать это на защите — план (1–2 минуты)

1. Цель: параллельно найти min/max в массиве, разбив задачу на `pnum` процессов.
2. Вход: `--seed`, `--array_size`, `--pnum`, опция `--by_files`.
3. Разбиение: показать формулу `chunk_size` + `remainder`, пример на `array_size=10, pnum=3`.
4. Показать ключевые фрагменты кода:
   - разбиение на диапазоны (`begin/end`);
   - код дочернего процесса (вызов `GetMinMax`, запись в файл/pipe, `_exit`);
   - код родителя (wait, чтение, агрегация).
5. Упомянуть про закрытие концов pipe и использование `_exit`.
6. Демонстрация: запустить `sequential` и `parallel` с одинаковыми параметрами и показать, что min и max совпадают.

---

Если хотите, могу:
- экспортировать этот файл в формат `.docx` и дать ссылку для скачивания; либо
- добавить краткие слайды (3–4 пункта) готовые для вставки в презентацию.

Скажите, что предпочитаете.